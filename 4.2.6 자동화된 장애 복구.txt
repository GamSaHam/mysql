InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재돼 있다. 그러한 메커니즘을 이용해 MySQL
서버가 시작될 때 완료되지 못한 트랜젝션이나 디스크에 일부만 기록된(Partial write) 데이터 페이지 등에 대한 일련의 복구
적업이 자동으로 진행된다.

InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않는다.
하지만 MySQL 서버와 무관하게 디스크나 서버 하드웨어 이슈로 InnoDB 스토리지 엔진이 자동으로 복구 못하는 경우도 발생하는데
일단 한번 문제가 생기면 복구하기가 쉽지 않다. 

MySQL 서버의 설정 파일에 innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버를 시작해야 한다.

InnoDB의 로그 파일이 손상됐다면 6으로 설정하고 MySQL 서버를 기동한다.
InnoDB 테이블의 데이터 파일이 손상됐다면 1로 설정하고 MySQL 서버를 기동한다.

- 어떤 부분이 문제인지 알 수 없다면 innodb_force_recovery 설정값을 1부터 6까지 변경하면서 MySQL을 재시작해 본다.

일단 MySQL 서버가 기동되고 InnoDB 테이블이 인식된다면 mysqldump를 이용해 데이터를 가능한 만큼 백업하고 그 데이터로
MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋다. 

- 1(SRV_FORCE_IGNORE_CORRUPT)
    InnoDB의 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 MySQL 서버를 시작한다. 에러 로그
    파일에 'Database page curruption on disk or a failed' 메시지가 출력될 때는 대부분 이 경우에 해당한다.
    이때는 mysqldump 프로그램이나 SELECT INFO OUTFILE... 명령을 이용해 덤프해서 데이터베이스를 다시 구축하는 것이 좋다.

- 2(SRV_FORCE_ON_BACKGROUND)
    InnoDB는 쿼리를 실행하기 위해 여러 종류의 백그라운드 스레드를 동시에 사용한다. 이 복구 모드에서는 이러한 백그라운드 스레드
    가운데 메인 스레드를 시작하지 않고 MySQL 서버를 시작한다. InnoDB는 트랜잭션의 롤백을 위해 언두 데이터를 관리하는데,
    트랜잭션이 커밋되어 불필요한 언두 데이터는 InnoDB의 메인 스레드에 의해 주기적으로 삭제하는 과정에서 장애가 발생한다면
    이 모드로 복구하면 된다.

- 3(SRV_FORCE_NO_TRX_UNDO)
    InnoDB에서 트랜잭션이 실행되면 롤백에 대비해 변경 전의 데이터를 언두 영역에 기록한다. 일반적으로 MySQL 서버는 다시 시작하면서
    언두 영역의 데이터를 먼저 데이터 파일에 적용하고 그 다음 리두 로그의 내용을 다시 덮어써서 장애 시점의 데이터 상태를 만들어
    낸다. innodb_force_recovery가 3으로 설정되면 커밋되지 않은 트랜잭션의 작업을 롤백하지 않고 그대로 놔준다.
    즉, 커밋되지 않고 종료된 트랜잭션은 계속 그 상태로 남아 있게 MySQL 서버를 시작하는 모드다. 이때도 우선 MySQL 서버가 
    시작되면 mysqldump를 이용해 데이터를 백업해서 다시 데이터베이스를 구축하는 것이 좋다.

- 4(SRV_FORCE_NO_IBUF_MERGE)
    InnoDB는 INSERT, UPDATE, DELETE 등의 데이터 변경으로 인한 인덱스 변경 작업을 상황에 따라 즉시 처리할 수도 있고
    인서트 버퍼에 저장해두고 나중에 처리할 수도 있다. 
    innodb_force_recovery를 4로 설정하면 InnoDB 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 MySQL이 시작되게 한다.

- 5(SRV_FORCE_NO_UNDO_LOG_SCAN)
    MySQL 서버가 장애나 정상적으로 종료되는 시점에 진행 중인 트랜잭션이 있었다면 MySQL은 그냥 단순히 그 커넥션을 강제로
    끊어 버리고 별도의 정리 작업 없이 종료한다. MySQL이 다시 시작하면 InnoDB 엔진은 언두 레코드를 이용해 데이터 페이즈를
    복구하고 리두 로그를 적용해 종료 시점이나 장애 발생 시점의 상태를 재현해 낸다. 
    그리고 InnoDB는 마지막으로 커밋되지 않은 트랜잭션에 변경한 작업은 모두 롤백 처리한다. 그런데 InnoDB의 언두 로그를
    사용할 수 없다면 InnoDB 엔진의 에러로 MySQL 서버를 시작할 수 없다.

    innodb_foruce_recovery 옵션을 5로 설정하면 InnoDB 엔진의 언두 로그를 모두 무시하고 MySQL을 시작할 수 있다.

- 6(SRV_FORCE_NO_LOG_REDO)
    InnoDB 스토리지 엔진의 리두 로그가 손상되면 MySQL 서버가 시작되지 못한다. 이 복구 모드로 시작하면 InnoDB엔진은 리두
    로그를 모두 무시한 채로 MySQL 서버가 시작된다. 또한 커밋돘다 하더라도 리두 로그에만 기록되고 데이터 파일에 기록되지 않은
    데이터는 모두 무시된다.

위와 같이 진행했음에도 MySQL 서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다. 백업이 있다면 마지막 백업
으로 데이터베이스를 새로 구축하고, 바이너리 로그를 사용해 최대한 장애 시점까지의 데이터를 복구할 수도 있다. 백업은 있지만
복제의 바이너리 로그가 없거나 손실됐다면 마지막 백업 시점까지만 복구할 수 있다.

더 자세한 내용은 MySQL 매뉴얼의 innodb_force_recovery 시스템 변수의 내용을 참조한다.











