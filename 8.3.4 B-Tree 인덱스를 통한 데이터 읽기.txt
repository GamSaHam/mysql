
MySQL이 인덱스를 이용하는 대표적인 방법 세 가지를 살펴보겠다.

1. 인덱스 레인지 스캔
인덱스의 접근 방법 가운데 가장 대표적인 접근 방식으로
다음 쿼리를 예제로 살펴보자.
mysql> select * from employees where first_name between 'Ebbe' AND 'Gad';

루트 노드(페이지)
페이지(1)
인덱스 키, 자식노드 주소
Aamer, 2
Jaana, 3

브랜치 노드(페이지)
페이지(2)
인덱스 키, 자식노드 주소
Aamer, 4
Ebbe, 5
Gad, 6

리프 노드(페이지)
페이지(4)
인덱스 키, 프라이머리 키
Amamer, 11800
...
페이지(5)
Ebbe, 10057
Fabrizio, 11854
...
페이지(6)
Gad, 10799
...

그림 8.8 요약

인덱스를 이용한 레인지 스캔에서 루트 노드에서 Aamer 를 스캔하고 브랜치 노드에서 Ebbe를 스캔하고
리프 노드에서 Ebbe를 찾는다. between 구문이니 Gad 까지 레인지 스캔을 한다.
페이지(5) Ebbe부터 Gad까지 스캔하는 것을 레인지 스캔이라고 한다.

인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다. 
검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현한다. 
그림 8.8의 화살표에서도 알 수 있듯이 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 필요한
레코드의 시작 지점을 찾을 수 있다. 일단 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다. 이 처럼 차례대로 쭉 읽는 것을 스캔이라고 표현한다.

만약 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔한다. 그리고 최종적으로 스캔을 멈춰야할 위치에 다다르면 지금
까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다.

그림 8.8은 실제 인덱스만 읽는 경우를 보여준다. 하지만 B-Tree 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야 하는 경우도 많은데 이 과정을 
살펴보자

리프 노드 페이지
페이지(5)
Ebbe, 10057
Fabrizio, 11854
...
페이지(6)
Gad, 10799
...

데이터 파일
emp_no, first_name, ...
10057, Ebbe, ...
Fabrizio, 11854, ...
...,
Gad, 10799, ...
그림 8.9 요약

B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고 그 방향 으로 인덱스를 읽어 나가는 과정을 그림 8.9에서 확인할 수 있다. 
인덱스를 구성하는 정렬된 칼럼에서 정순 또는 역순으로 상태로 레코드를 가져온다.

리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어난다.
그림 8.9에서 처럼 3건의 레코드가 검색 조건에 일치했다고 가정하면, 데이터 레코드를 읽기 위해 랜덤 I/O가 최대 3번 필요한 것이다.
그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류 된다.


















