InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블
락으로 레벨업되는 경우는 없다. 일반 사용 DBMS와는 조금 다르게 InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을
잠그는 갭(GAP) 락이라는 것이 존재하는데 그림 5.1 은 InnoDB 스토리지 엔진의 레코드 락과 레코드 간의 간격을 잠그는 갭 락을 보여준다.

인덱스 
Adamantios - (레코드락)
... Alejandro ... 
Anneke(넥스트 키 락)
... Christan ...(넥스트 키 락, 갭락)
Duangkaew(갭락)
... Eberhardt ...
Georgi

그림 5.1 InnoDB 잠금의 종류(점선의 레코드는 실제 존재하지 않은 레코드를 가정한 것임)

5.3.1.1 레코드 락
레코드 자체만을 잠그는 것을 레코드 락(Record lock, Record only lock)이라고 하며, 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다.
인덱스의 레코드를 잠근다는 점이다. 

InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 이어서 설명할 넥스트 키 락(Next key lock) 또는 갭 락(Gap lock)을 사용하지만 
프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭(Gap, 간격)에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.

5.3.1.2 갭락
갭 락은 레코드 자체가 아니라 레코드와 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다. 

5.3.1.3 넥스트 키 락
레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락(Next key lock)이라고 한다. STATEMENT 포맷의 바이너리 로그에 사용하는 MySQL 서버에서는
REPRATABLE READ 격리 수준을 사용해야 한다. InnoDB의 갭 락이나 넥스트키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스
서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다. 그런데 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나
다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다. 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

MySQL 5.5 버전까지는 ROW 포맷의 바이너리 로그가 도입된 지 오래되지 않아서 그다지 너리 사용되지 않았다. MySQL 8.0에서는 ROw 포캣의 바이너리 로그가
기본 설정으로 변경됐다.

5.3.1.4 자동 증가 락
MySQL에서는 자동 증가하는 숫자 값을 추출(채번)하기 위해 AUTO_INCREMENT라는 칼럼 속성을 제공한다. AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에
여러 레코드가 INSERT되는 경우, InnoDB 스토리지 엔진에서는 이를 위해 AUTO_INCREMENT 락(Auto incremnet lock)이라는 테이블 수준의 잠금을 사용한다.

AUTO_INCREMENT 락은 INSERT와 REPLACE 쿼리 문장과 같은 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE나 DELETE 등의 쿼리에서는 걸리지 않는다.
InnoDB의 다른 잠금(레코드 락이나 넥스트 키 락)과는 달리 AUTO_INCREMENT 락은 트랜잭션과 관계없이 INSERT나 REPLACE 문자에서 AUTO_INCREMNET 값을
가져오는 순간만 락이 걸렸다가 즉시 해제된다.

AUTO_INCREMENT 락은 아주 짦은 시간동안 걸렸다가 해제되는 잠금이라서 대부분의 경우 문제가 되지 않는다. 









