
MySQL 엔진에서는 테이블 데이터 동기화를 위한 테이블 락 이외에도 테이블의 구조를 잠그는 메타데이터 락(Metadata Lock) 그리고 사용자의 필요에 맞게 사용
할 수 있는 네임드 락(Named Lock) 이라는 잠금 기능도 제공한다.

한 세션이 글로벌 락을 획득하면 다른 세션에서 select를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 떄까지 해당 문장이
대기 상태로 남는다. 

특정 세션에서 백업 락을 획득하면 모든 세션에서 다음과 같이 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.
 - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
 - REPIAR TABLE과 OPTIMIZE TABLE 명령
 - 사용자 관리 및 비밀번호 변경

하지만 백업 락은 일반적인 테이블 데이터 변경은 허용된다. 일반적인 MySQL 서버의 구성은 소스 서버(Source server)와 레플리카 서버(Replica Server)
로 구성되는데, 주로 백업은 레플리카 서버에서 실행된다.

5.2.2 테이블 락
명시적인 테이블 락도 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없다.
글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문이다.

묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하느 쿼리를 실행하면 발생한다. MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고
데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용된다. 즉, 묵시적인 락은 테이블 락이 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료
된 후 자동으로 해제된다. 하지만 InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인
테이블 락이 설정되지 않는다. 대부분의 데이터변경(DML) 쿼리에는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.

5.2.3 네임드 락
네임드 락(Named Lock)은 GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다. 이 잠금의 특징은 대상이 테이블이나 레코드 또는
AUTO_INCREMENT와 같은 데이터베이스 객체가 아니라는 것이다. 네임드 락은 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하는
잠금이다. 예를 들어, 데이터베이스 서버 1대의 5대의 웹서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건
처럼 여러 클라이언트가 상호 동기화를 처리할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.

배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원이이 되곤 한다. 이러한 경우에 동일 데이터를 변경하거나
참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있다.


select get_lock('mylock_1', 10);
select get_lock('mylock_2', 10);

select release_lock('mylock_2');
select release_lock('mylock_1');

-- mylock_1과 mylock_2를 동시에 모두 해제하고자 한다면 RELEASE_ALL_LOCKS() 함수 사용
select release_all_locks();





















