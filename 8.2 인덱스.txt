
DBMS 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의
쌍으로 삼아 인덱스를 만들어 두는 것이다. 그리고 책의 "찾아보기"와 DBMS 인덱스의 공통점은 가운데 중요한 것이 바로 정렬이다. 책 찾아보기는 최대한 빠르게 찾아
갈 수 있게 "ㄱ", "ㄴ", "ㄷ", ... 과 같은 순서로 정렬돼 있는데, DBMS의 인덱스도 마찬가지로 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

SotedList는 DBMS의 인덱스와 같은 자료 구조이며, ArrayList는 데이터 파일과 같은 자료 구조를 사용한다. SortedList는 저장되는 값을 항상 정렬된 상태로
유지하는 자료 구조이며, ArrayList는 값을 저장되는 순서 그대로 유지하는 자료 구조다. DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해
항상 정렬된 상태를 유지한다.

그러면 이제 SortedList의 장담점을 통해 인덱스의 장담점을 살펴보자. SortedList 자료 구조는 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정
이 복잡하고 느리지만, 이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있다. DBMS의 인덱스도 인덱스가 많은 테이블은 당연히 INSERT나 UPDATE, DELETE 문장의
처리가 느려진다. 하지만 찾아보기용 표(인덱스)를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리할 수 있다.

결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. 여기서도 알 수 있듯이 테
이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다.
select 쿼리 문장의 where 조건절에 사용되는 컬럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만
불러올 수 있다.

이 책에서는 키(Key)라는 말과 인덱스(Index)는 같은 의미로 사용하겠다. 인덱스를 역할별로 구분해 본다면 프리이머리 키(Primary key)와 보조 키(세컨더리 인덱스,
Secondary key)로 구분할 수 있다.

프러이머리 키를 제외한 나머지 모든 인덱스는 Secondary Index로 분류한다. 

데이터 저장 방식(알고리즘)별로 구분할 경우 사실 상당히 많은 분류가 가능하겠지만 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.
최근에는 Fractal-Tree, Merge-Tree 인덱스와 같은 알고리즘을 사용하는 DBMS도 개발되고 있다.

Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

유니크 인덱스에 대해 동등조건 (Equal, =)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 데 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.

루투 노드가 존재하고 하위 노드를 리프 노드라 한다. 그 외를 브랜치 노드라고 한다. 


루트 노드(페이지)

페이지(1)
인덱스 키, 자식 노드 주소
Aaner, 2
Jaana, 3
...

브랜치 노드(페이지)
페이지(2)
인덱스키, 자식노드 주소
Aaner, 4
Ebbe, 5
Gad, 6
...

페이지(3)
인덱스 키, 자식노드 주소
Janna, 7
Lakshmi, 8
Oddvar, 9
...

리프 노드(페이지)

페이지(4)
인덱스 키, 프라이머리 키
Aanner, 11800
Babette, 10128
Candida, 10418
...

페이지(5)
인덱스 키, 프라이머리 키
Ebbe, 10057
Fabrizio, 11854
...

페이지(6)
인덱스 키, 프라이머리 키
Gad, 10799
Hailing, 11005
Iara, 11043
...

페이지(7)
인덱스 키, 프라이머리 키
Jaana, 11384
Kagan, 12338
...

데이터 파일
그림 8.4

위와같이 인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다. 많은 사람들이 데이터 파일의 레코드는 INSERT
된 순서대로 저장되는 것으로 생각하지만 그렇지 않다. 

8.3.2 B-Tree 인덱스 키 추가 및 삭제

B-Tree의 키 값이 삭제되는 경우는 상당히 간단하다. 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.

8.3.2.3 인덱스 키 변경
B-Tree의 키 값 변경 작업은 먼저 키 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다. 

8.3.2.4 인덱스 키 검색
부등호 ("<", ">") 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다. 

8.3.3.1 인덱스 키 값의 크기
InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(Page) 또는 블록(Block)이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소
작업 단위가 된다. 루트와 브랜치, 리프 노드를 구분한 기준이 바로 페이지 단위다.

DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. B-Tree는 자식 노드를 몇 개까지 가지는지 궁금할 것이다. 그것이 바로 인덱스의 페이지 크기와 키 값의
크기에 따라 결정된다. InnoDB 스토리지 엔진의 페이지 크기를 innodb_page_size 시스템 변수를 설정하고 기본값은 16KB이다.

인덱스 페이지
1233____ABCD____, 자식노드 주소
1233____ABCD____, 자식노드 주소
1233____ABCD____, 자식노드 주소

16(8+8) 바이트, 12바이트

그림 8.7의 경우 하나의 인덱스 페이지(16KB)에 몇 개의 키를 저장할 수 있을까? 16*1024/(16+12) = 585개 저장할 수 있다. 최종적으로 이 경우는 자식 노드를 585개
를 가질 수 있는 B-Tree가 되는 것이다. 

인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미한다.

또한 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미한다. 














