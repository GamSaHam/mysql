인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 인덱스를 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔 방식이 사용된다. 
예를 들어 인덱스 (A, B, C)칼럼의 순서로 만들어져 있지만 쿼리의 조건절은 B컬럼이나 C칼럼으로 검색하는 경우다.

일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다는 인덱스만 읽는 것이 효율적이다. 쿼리가 인덱스에
명시된 컬럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용 된다. 인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 
않는다. 간단하게 그림으로 인덱스 풀 스캔의 처리 방식을 살펴보자.

먼저 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 후, 인덱스의 리프 노드를 연결하는 링크드 리스트(Linked list)를 따라서 처음부터 끝까지 스캔하는 방식을
인덱스 풀 스캔이라고 한다. 이 방식은 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. 앞에서도 언급 했듯이 인덱스에 포함된 칼럼만으로
쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문이다. 인덱스의 전체 크기는 테이블 자체의 크기보다는 훨씬 작으므로 인덱스 풀 스캔은
테이블 전체를 읽는 것보다는 적은 디스크 I/O로 쿼리를 처리할 수 있다.

이 책에서 특별히 방식을 언급하지 않고 "인덱스를 사용한다"라고 표현한 것은 "인덱스 레인지 스캔"이나 뒤에서 설명할 "루스 인덱스 스캔"방식으로 인덱스를 
사용한다는 것을 의미한다. 

인덱스 풀 스캔 방식 또한 인덱스를 이용하는 것이지만 효율적인 방식은 아니며, 일반적으로 인덱스를 생성하는 목적은 아니다. 

8.3.4.3 루스 인덱스 스캔
많은 사용자에게 루스(Lose) 인덱스 스캔이라는 단어는 상당히 생소할 것이다. 오라클과 같은 DBMS의 인덱스 스킵 스캔 이라고 하는 기능과 작동 방식은 비슷하지만
MySQL에서는 이를 루스 인덱스 스캔 이라고 한다. MySQL 5.7 버전까지는 MySQL의 루스 인덱스 스캔 기능이 많이 제한적이었지만, MySQL 8.0버전부터는 다른 상용
DBMS에서 지원하는 두 가지 접근 방법("인덱스 레인지 스캔"과 "인덱스 풀 스캔")은 "루스 인덱스 스캔"과는 상반된 의미에서 "타이트(Tight) 인덱스 스캔"으로
분류한다. 루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.

루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값을 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다.
일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용된다.

mysql> select dep_no, min(emp_no) from dept_emp where dep_no between 'd002' and 'd004' group by dept_no;

이 쿼리에서 사용된 dept_emp 테이블은 dep_no와 emp_no라는 두 개의 칼럼으로 인덱스가 생성돼 있다. 이 인덱스는 (dept_no, emp_no) 조합으로 정렬까지 돼
있어서 그림 8.11에서와 같이 dept_no 그룹 별로 첫 번째 레코드의 emp_no 값만 읽으면 된다.
즉 인덱스에서 where 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있기 때문에 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 
이동한다.

그림 8.11을 보면 인덱스 리프 노드를 스캔하면서 불필요한 부분은 그냥 무시하고 필요한 부분(회색 바탕 색깔의 레코드)만 읽었음을 알 수 있다. 루스 인덱스 스캔을 사용하려면
여러 가지 조건을 만족해야 하는데, 이러한 제약 조건은 10장 '실행 계획'에서 자세히 언급하겠다.














