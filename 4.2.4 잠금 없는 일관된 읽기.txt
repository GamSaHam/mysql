InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다. 잠금을 걸지 않기 때문에 InnoDB에서 읽기 
작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다. 격리 수준이 SERIALIZABLE이 아닌 READ_UNCOMMITED나
READ_COMMITED, REPEATABLE_READ 수준인 경우 insert와 연결되지 않는 순수한 읽기(select) 작업은 다른 트랜잭션의 변경 작업과
관계없이 항상 잠금을 대기하지 않고 바로 실행된다.

특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다. 하더라도 이 변경 트랜잭션이 다른 사용자의 select 작업을 방해하지
않는다. 이를 '잠금 없는 일관된 읽기' 라고 표현하며, InnoDB에서는 변경되기 전에 데이터를 읽기 위해 언두 로그를 사용한다.

사용자1 -> update area = '경기' 
사용자2 -> select 언두로그 area = '서울'

그림 4.12 잠겨진 레코드 읽기

오랜 시간 동안 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있는데, 바로 이러한 일관된 읽기
를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제다. 따라서 트랜잭션이 시작됐다면 가능한 빨리
롤백이나 커밋을 통해 트랜잭션을 완료 하는 것이 좋다.

4.2.5 자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 잠금이나 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태
로 관리한다. InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 
교착 상태에 빠진 트랜젝션들을 찾아서 그중 하나를 강제 종료한다. 이때 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은
트랜잭션의 언두 로그 양이며, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다. 

참고로 InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금(LOCK 91TABLES 명령으로 잠긴 테이블)을 볼 수가
없어서 데드락 감지가 불확실 할 수도 있다.

일반적인 서비스에서 데드락 감지 스레드가 트랜잭션의 잠금 목록을 검사해서 데드락을 찾아내는 작업은 크게 부담되지 않는다. 

하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다.
데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트에 새로운 잠금을
걸고 데드락 스레드를 찾게 된다.

이런 문제점을 해결하기 위해 MySQL 서버는 innodb_deadlock_detect 시스템 변수를 제공하며, innodb_deadlock_detect를
OFF로 설정하면 데드락 감지 스레드는 더는 작동하지 않게 된다. 

데드락 감지 스레드가 부담되어 innodb_deadlock_detect를 OFF 설정해서 비활성화하는 경우라면 innodb_lock_wait_timeout을
기본값 50초보다 훨씬 낮은 시간으로 변경해서 사용할 것을 권장한다.

구글에서는 프라이머리 키 기반의 조회 및 변경이 아주 높은 빈도로 실행되는 서비스가 많았는데, 트랜젝션을 동시에 실행하기
때문에 데드락 감지 스레드가 상당히 성능을 저하시킨다는 것을 알아냈다. innodb_deadlock_detect를 비활성하해서 성능
비교를 해보는 것도 새로운 기회가 될것이다.
























