
InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로
 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다. 버퍼 풀의 페이지 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게
LRU(Least Recently Used) 리스트와 플러시(Flush) 리스트, 그리고 프리(Free) 리스트라는 3개의 자료 구조를 관리한다.
프리 리스트는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자 쿼리가 새롭게
디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다. LRU 리스트는 그림 4.13과 같은 구조를 띠고 있는데,
엄밀하게 LRU와 MRU 리스트가 결합된 형태라고 보면 된다. 그림 4.13에서 'Old 서브리스트' 영역은 LRU에 해당하며, 
'New 서브리스트' 영역은 MRU 정도로 이해하면 된다.

New 서브리스트(head <-> tail), Old 서브리스트(head <-> tail)

데이터 페이지를 읽으면 new 리스트의 머리쪽으로 이동
사용하지 않는 데이터는 페이지는 old 리스트의 꼬리쪽으로 이동

LRU 리스트를 관리하는 목적은 디스크로 부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서
디스크 읽기를 최소화하는 것이다. 

1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
    A. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
    B. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색
    C. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급

2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가

3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동

4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(Age)가 부여되며, 
(Aging) 은 버퍼풀에서 제거된다. 버퍼 풀의 데이터 페이지가 쿼리에서 의해 사용되면 나이가 초기화 되어 다시 젊어지고
MRU의 헤더 부분으로 옮겨진다.

5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가

4.2.7.3 버퍼 풀과 리두 로그
InnoDB의 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다. InnoDB 버퍼 풀은 서버의 메모리가 허용하는 만큼
크게 설정하면 할수록 쿼리의 성능이 빨라진다. 

InnoDB의 버퍼 풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지(Clean Page)와 함께 INSERT, UPDATE
명령으로 변경된 데이터를 가진 더티 페이지(Dirty PAge)도 가지고 있다. 데이터 변경이 계속 발생하면 리두 로그 파일에 
기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다. 재사용이 불가능한 공간을 활성 리두 로그 (Active Redo Log)
라고 한다. 

리두 로그 파일의 공간은 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 계속 증가된 값을 갖게 되는데, 이를
LSN(Log Sequence Number) 라고 한다. InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼
풀의 더티 페이지를 디스크로 동기화하는데

InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고, 체크포인트가 발생하면 체크포인트 LSN보다
작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 한다. 

1. InnoDB 버퍼 풀은 100GB이며 리두 로그 파일의 전체 크기는 100MB인 경우
2. InnoDB 버퍼 풀은 100MB이며 리두 로그 파일의 전체 크기는 100GB인 경우

1번의 경우 리두 로그 파일의 크기가 100MB밖에 안 되기 때문에 체크포인트 에지도 최대 100MB만 허용된다.
평균 리두 로그 엔트리가 4KB였다면 25600 개 (100MB/4KB) 정도의 더티 페이지만 버퍼 풀에 보관할 수 있게 된다.
데이터 페이지가 16KB라고 가정한다면 허용 가능한 전체 더티 페이지는 크기는 400MB수준 밖에 안 되는 것이다.

결국 이 경우는 버퍼 풀의 크기는 매우 크지만 실제 쓰기 버퍼링을 위한 효과는 거의 못 보는 상황인 것이다. 2번의 경우도
1번과 동일한 방식으로 계산해볼 수 있는데, 대략 400GB 정도의 더티 페이지를 가질 수 있다. 
하지만 버퍼 풀의 크기가 100MB이기 때문에 최대 허용 가능한 더티 페이지는 100MB 크기가 된다.

버퍼 풀에 더티 페이지의 비율이 너무 높은 상태에서 갑자기 버퍼 풀이 필요해지는 상황이 오면 InnoDB 스토리지 엔진은 매우
많은 디티 페이지를 한 번에 기록해야 하는 상황이 온다. 100GB 이하의 MySQL 서버에서는 리두 로그 파일의 전체 크기를 대략
5~10GB 수준으로 선택하고 필요할 때마다 조금씩 늘려가면서 최적값을 선택하는 것이 좋다.

당연한 이야기지만 버퍼 풀의 크기가 100GB라고 해서 리두 로그의 공간이 100GB가 돼야 한다는 것은 아니다. 일반적으로
리두 로그는 변경분만 가지고 버퍼 풀은 데이터 페이지를 통째로 가지기 때문에 데이터 변경이 발생해도 리두 로그는 훨씬 
작은 공간만 있으면 된다.

4








